package com.sap.cloud.security.xsuaa.token.flows;

import com.sap.cloud.security.xsuaa.backend.*;
import com.sap.xsa.security.container.XSTokenRequest;
import org.springframework.lang.Nullable;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.util.Assert;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;

import static com.sap.cloud.security.xsuaa.token.flows.XsuaaTokenFlowsUtils.buildAuthorities;

/**
 * A client credentials flow builder class. Applications retrieve an instance of
 * this builder from {@link XsuaaTokenFlows} and then create the flow request
 * using a builder pattern.
 */
public class ClientCredentialsTokenFlow {

	private static final String AUTHORITIES = "authorities";

	private XSTokenRequest request;
	private VariableKeySetUriTokenDecoder tokenDecoder;
	private OAuth2Server oAuth2Server;
	private OAuth2ServerEndpointsProvider endpointsProvider;

	/**
	 * Creates a new instance.
	 *
	 * @param oAuth2Server - the {@link OAuth2Server} used to execute the final request.
	 * @param tokenDecoder - the token decoder
	 * @param endpointsProvider - the endpoints provider
	 */
	ClientCredentialsTokenFlow(OAuth2Server oAuth2Server, VariableKeySetUriTokenDecoder tokenDecoder,
			OAuth2ServerEndpointsProvider endpointsProvider) {
		Assert.notNull(oAuth2Server, "OAuth2Server must not be null.");
		Assert.notNull(tokenDecoder, "TokenDecoder must not be null.");
		Assert.notNull(endpointsProvider, "OAuth2ServerEndpointsProvider must not be null.");

		this.oAuth2Server = oAuth2Server;
		this.tokenDecoder = tokenDecoder;
		this.endpointsProvider = endpointsProvider;

		this.request = new XsuaaTokenFlowRequest(endpointsProvider.getTokenEndpoint());
	}

	/**
	 * Adds the OAuth 2.0 client ID to the request.<br>
	 * The ID needs to be that of the OAuth client that requests the token.
	 *
	 * @param clientId - the ID of the OAuth 2.0 client requesting the token.
	 * @return this builder.
	 */
	public ClientCredentialsTokenFlow client(String clientId) {
		request.setClientId(clientId);
		return this;
	}

	/**
	 * Adds the OAuth 2.0 client's secret to this request.<br>
	 * The secret needs to be the one of the client that requests the token.
	 *
	 * @param clientSecret - the secret of the OAuth 2.0 client requesting the token.
	 * @return this builder.
	 */
	public ClientCredentialsTokenFlow secret(String clientSecret) {
		request.setClientSecret(clientSecret);
		return this;
	}

	/**
	 * Adds additional authorization attributes to the request. <br>
	 * Clients can use this to request additional attributes in the
	 * {@code 'az_attr'} claim of the returned token.
	 *
	 * @param additionalAuthorizationAttributes - the additional attributes.
	 * @return this builder.
	 */
	public ClientCredentialsTokenFlow attributes(Map<String, String> additionalAuthorizationAttributes) {
		this.request.setAdditionalAuthorizationAttributes(additionalAuthorizationAttributes);
		return this;
	}

	/**
	 * Executes the token flow and returns a JWT token from XSUAA.
	 *
	 * @return the JWT token generated by XSUAA.
	 * @throws TokenFlowException in case of token flow errors.
	 */
	public Jwt execute() throws TokenFlowException {
		checkRequest(request);

		return requestTechnicalUserToken(request);
	}

	/**
	 * Checks if the built request is valid. Throws an exception if not all
	 * mandatory fields are filled.
	 *
	 * @param request - the token flow request.
	 * @throws TokenFlowException in case the request does not have all mandatory fields set.
	 */
	private void checkRequest(XSTokenRequest request) throws TokenFlowException {
		if (!request.isValid()) {
			throw new TokenFlowException(
					"Client credentials flow request is not valid. Make sure all mandatory fields are set.");
		}
	}

	/**
	 * Requests the client credentials token from XSUAA.
	 *
	 * @param request - the token request.
	 * @return the JWT token returned by XSUAA.
	 * @throws TokenFlowException in case of an error during the flow.
	 */
	@Nullable
	private Jwt requestTechnicalUserToken(XSTokenRequest request) throws TokenFlowException {
		Map requestParameter = new HashMap();
		String authorities = buildAuthorities(request);
		if (authorities != null) {
			requestParameter.put(AUTHORITIES, authorities); // places JSON inside the URI !?!
		}

		try {
			OAuth2AccessToken accessToken = oAuth2Server
					.retrieveAccessTokenViaClientCredentialsGrant(request.getTokenEndpoint(),
							new ClientCredentials(request.getClientId(), request.getClientSecret()), requestParameter);
			return decode(accessToken.getValue(), endpointsProvider.getJwksUri());
		} catch (OAuth2ServerException e) {
			throw new TokenFlowException(
					String.format("Error requesting user token with grant_type 'client_credentials': %s",
							e.getMessage()));
		}
	}

	/**
	 * Decodes the returned JWT value.
	 * validation is not required by the one who retrieves the token,
	 * but by the one who receives it (e.g. the service it is sent to).
	 * Hence, here we only decode, but do not validate.
	 * decoder.setJwtValidator(new
	 * DelegatingOAuth2TokenValidator<>(tokenValidators));
	 *
	 * @param encodedToken - the encoded JWT token value.
	 * @return the decoded JWT.
	 * @throws TokenFlowException in case of an exception decoding the token.
	 */
	private Jwt decode(String encodedToken, URI keySetEndpoint) {
		// TODO not a good idea as singleton bean instance
		tokenDecoder.setJwksURI(keySetEndpoint);
		return tokenDecoder.decode(encodedToken);
	}
}
